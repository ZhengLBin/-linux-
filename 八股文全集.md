# 📘 计算机八股文题库

> 📅 更新日期：2025-07-04  

---

## ✳️ 目录

- [操作系统](#操作系统)
- [计算机网络](#计算机网络)
- [数据结构与算法](#数据结构与算法)
- [C/C++ 基础](#cc-基础)
- [Linux / 系统编程](#linux--系统编程)
- [数据库](#数据库)
- [设计模式](#设计模式)
- [音视频相关](#音视频相关)
- [其他](#其他)


---

## 操作系统

### Q1: 什么是进程、线程，有什么区别？（什么时候用进程，什么时候用线程）

**答：**

- 进程是**资源**（cpu，内存）分配的基本单位，线程是**cpu调度和分配**的基本单位，也是程序执行的最小单位。
- 进程由进程控制块，代码段，数据段组成。**进程本身不运行程序**，它就像一个容器一样，一开始会先创建出一个主线程，给他分配进程的部分系统资源，这时候就可以在主线程实现各种功能。
- 当我们需要**频繁创建和销毁**的时候使用线程，因为进程创建开销大。需要**大量传输数据**的时候也使用线程，因为线程切换速度快，不用跨越进程边界。
- 如果需要安全稳定使用进程，快速频繁的场景使用线程。如果线程出现严重问题，比如内存越界，可能会导致整个进程**崩溃**。而每个进程有独立的地址空间，一个进程崩溃通常不会影响其他进程

**举例子：**

- 比如chrome浏览器，它是多进程架构，它的标签就可以看作一个进程，单个标签页崩溃不会影响整个浏览器。而多线程程序，比如某些游戏引擎，某个线程出错可能导致整个游戏退出。


---
### Q2：多进程、多线程同步（通讯）的方法

**答**


多进程和多线程的同步方法有本质区别，核心在于它们是否共享地址空间。

*   多进程拥有独立的内存空间，它们的同步主要解决如何安全地交换数据和协调状态。
*   多线程共享其所属进程的内存空间（堆、全局变量等），它们的同步主要解决如何安全、有序地访问这些共享资源，防止数据不一致。

**一、多进程间通讯（IPC）方法：**

1.  管道 (Pipe)：
    *   分为**无名管道**（仅限有亲缘关系的进程，如父子进程）和**有名管道/FIFO**（通过文件系统路径供无关进程访问）。
    *   大数据传输效率不高，通常用作控制或小数据传输。
    *   **适用场景：** 适合简单的父子进程通信。

2.  信号 (Signal)：
    *   用于通知进程发生了某种**事件**（如 `SIGINT`, `SIGKILL`）。
    *   信息量极小（仅信号编号），**不适合数据交换**，主要用于进程控制或简单事件通知。

3.  共享内存 (Shared Memory)：
    *   **速度最快的IPC方式**。多个进程将**同一块物理内存映射**到各自的虚拟地址空间，进程可以直接读写这块内存进行通信。
    *   例如，在我实习期间的多摄像头采集同步的功能开发中，使用了 **GStreamer 的 `shmsink`/`shmsrc` 插件**用于通过共享内存传输同步后的数据流。
    *   **适用场景：** 适合高性能本地大数据共享，**需同步机制配合**（如信号量）。
4.  消息队列 (Message Queue)：
    *   在内核中维护的链表。进程可以发送结构化的、有类型/优先级的数据块（消息）到队列，其他进程按类型或优先级接收。
    *   例如，在音视频处理中，可以把帧数据的元信息（如时间戳、帧号、指向共享内存中实际帧数据的指针/偏移量）打包成一个消息发送到消息队列，消费进程可以从队列中取出消息，再根据元信息找到共享内存中的帧数据进行传输。
    *   **适用场景：** 适合多进程间结构化消息的**异步传输**。

5.  信号量 (Semaphore - IPC)：
    *   主要用于**进程间的同步**，控制多个进程对**一组共享资源**（如共享内存区域、文件）的访问。
    *   它是一个计数器，`P`操作（wait）尝试减少计数器（获取资源），`V`操作（signal）增加计数器（释放资源）。
    *   **关键作用：** 常作为其他IPC（如共享内存）的**同步工具**。

6.  套接字 (Socket)：
    *   最通用、最强大的IPC方式，**可用于不同主机或同一主机的进程间通信**。
    *   **TCP（可靠连接）和 UDP（无连接数据报）** 是典型的基于套接字的通信协议。
    *   **适用场景：** **是唯一支持跨主机通信的通用IPC方式**，适合网络通信和分布式应用。

**二、多线程同步方法：**

多线程同步主要通过**信号量、读写锁、条件变量、互斥锁、自旋锁**这几种机制来实现。需要根据具体场景选择不同的组合来解决**共享内存访问冲突**这个核心问题。

*   最经典的协作模式是 `互斥锁 + 条件变量`：
    *   **互斥锁 (Mutex)**：保证**同一时刻只有一个线程**能进入被保护的**临界区**（访问共享资源的代码段）。当一个线程持有锁时，其他尝试获取该锁的线程会被阻塞（休眠）。
    *   **条件变量 (Condition Variable)**：作用是**高效地让线程等待某个条件成立**，避免忙等待（Busy-Waiting）。它必须与一个互斥锁结合使用。
        *   例如，处理帧队列的线程（消费者）从队列中取帧处理，当条件不满足（如队列空）时，通过 `pthread_cond_wait()` **释放关联的互斥锁并让线程进入睡眠**。
        *   当另一个线程（生产者）改变了条件（如放入一帧数据），通过 `pthread_cond_signal()` 或 `pthread_cond_broadcast()` **唤醒等待的线程**。
        *   被唤醒的线程会**重新尝试获取关联的互斥锁**，并在获得锁后检查条件是否真正满足（避免虚假唤醒）。
*   **读写锁 (Read-Write Lock)**：适用于**读操作远多于写操作**的场景。允许多个线程**并发读**共享资源，但只允许**一个线程写**，且写时不能读。
*   **自旋锁 (Spinlock)**：在尝试获取已被持有的锁时，线程会在用户态**循环检查（“自旋”）锁是否被释放**，而不是立即休眠。适用于**临界区代码极短**且**多核心CPU**的环境（避免线程休眠唤醒的开销），长时间自旋会浪费CPU。
*   **信号量 (Semaphore - Thread)**：核心是一个**计数器**，`P`/`V`操作控制进入临界区的线程数量。允许多个线程（数量≤信号量值）同时进入临界区。互斥锁可视为初始值为1的信号量。

**项目应用实例：**
在我的多摄像头项目中，摄像头采集线程（生产者）将帧放入队列、以及处理线程（消费者）从队列取帧，就需要用到**互斥锁保护队列本身**，并**结合条件变量**让处理线程在队列空时高效等待、采集线程放入数据后唤醒它们，实现了高效的**生产者-消费者模型**。

## 计算机网络

### Q1: 什么？

**答：**

- 进程是资源分配的基本单位，线程是 CPU 调度的基本单位。
- 一个进程可以包含多个线程。
- 线程共享进程的资源，进程间资源独立。
- 创建/切换线程的开销比进程小。

**举例子：**

- xxxxx。


---

## 数据结构与算法

### Q1: 选择排序

#### 核心思想
> 每一轮都找**当前未排序部分中最小的元素**，把它放到**最前面**。

- 选择 → 交换。

#### 操作流程（以升序为例）
1. 从头开始，找到整个数组中最小的元素。
2. 把最小元素和第一个元素交换。
3. 再从第二个元素开始，找剩余中最小的，交换到第二个位置。
4. 以此类推，直到整个数组有序。


####  示例
排序 `[4, 2, 5, 1, 3]`：

- 找最小1，交换到第0位 ➔ `[1, 2, 5, 4, 3]`
- 找剩下最小2，已经在第1位，不动 ➔ `[1, 2, 5, 4, 3]`
- 找剩下最小3，交换到第2位 ➔ `[1, 2, 3, 4, 5]`
- 剩下自然有序。


#### 时间复杂度
- 最好、最坏、平均：**O(n²)**
- 空间复杂度：**O(1)**（原地排序）

**具体实现：**

```cpp
void selectionSort(vector<int>& nums) {
    int n = nums.size();
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;  // 假设当前位置i是最小的
        for (int j = i + 1; j < n; ++j) {
            if (nums[j] < nums[minIndex]) {
                minIndex = j;  // 找到更小的元素
            }
        }
        swap(nums[i], nums[minIndex]);  // 把最小的元素放到当前i的位置
    }
}
```
#### 讲解
- 外层循环：每次确定一个元素的位置。
- 内层循环：找从 `i` 到 `n-1` 最小的元素。
- 交换：把最小元素放到前面。

---
### Q2: 插入排序

#### 核心思想
> 每次拿一个新元素，**插入到已排好序的左边部分**，保持左边始终有序。

- 插入 → 移动 → 插入合适位置。


#### 操作流程
1. 第一个元素默认有序。
2. 第二个元素向左比较，插入合适位置。
3. 第三个元素向左比较，插入。
4. 以此类推。



#### 示例
排序 `[4, 2, 5, 1, 3]`：

- 4，自己有序。
- 2，比4小，插到前面 ➔ `[2, 4, 5, 1, 3]`
- 5，比4大，直接放后面。
- 1，比2小，插到最前 ➔ `[1, 2, 4, 5, 3]`
- 3，比5小，比4小，比2大，插到2后 ➔ `[1, 2, 3, 4, 5]`


#### 时间复杂度
- 最好（已经有序）：**O(n)**
- 最坏、平均：**O(n²)**
- 空间复杂度：**O(1)**

**具体实现：**

```cpp
void insertionSort(vector<int>& nums) {
    int n = nums.size();
    for (int i = 1; i < n; ++i) {
        int key = nums[i];  // 当前要插入的元素
        int j = i - 1;
        // 从后往前找位置
        while (j >= 0 && nums[j] > key) {
            nums[j + 1] = nums[j];  // 把大元素往后挪
            --j;
        }
        nums[j + 1] = key;  // 插入到正确位置
    }
}
```

#### 讲解
- `key`是当前新来的元素。
- 内层循环：把左边大于`key`的元素往后移动。
- 插入：空出的位置就是`key`该插的位置。

---
### Q3: 归并排序
#### 核心思想
> 把数组一分为二，分别排好序，然后**合并成一个有序数组**。

- 分治思想：**分而治之**！

#### 操作流程
1. 把数组对半分成两部分。
2. 递归地分别对左右部分排序。
3. 合并两个排好序的子数组。

#### 示例
排序 `[4, 2, 5, 1, 3]`：

- 切分： `[4,2,5]` `[1,3]`
- `[4,2,5]`继续分成 `[4] [2,5]`
- `[2,5]`分成 `[2] [5]`
- 合并`[2,5]`
- 合并`[4,2,5]` ➔ `[2,4,5]`
- `[1,3]`分成 `[1] [3]` ➔ 合并 `[1,3]`
- 最后合并 `[2,4,5]` 和 `[1,3]` ➔ `[1,2,3,4,5]`

#### 时间复杂度
- 不管怎样都是：**O(n log n)**
- 空间复杂度：**O(n)**（需要额外辅助数组）

**具体实现：**
```cpp
void merge(vector<int>& nums, int left, int mid, int right) {
    vector<int> temp; // 临时数组
    int i = left, j = mid + 1;
    while (i <= mid && j <= right) {
        if (nums[i] <= nums[j]) {
            temp.push_back(nums[i++]);
        } else {
            temp.push_back(nums[j++]);
        }
    }
    while (i <= mid) temp.push_back(nums[i++]);
    while (j <= right) temp.push_back(nums[j++]);
    
    // 把排好序的temp拷回原数组
    for (int k = 0; k < temp.size(); ++k) {
        nums[left + k] = temp[k];
    }
}

void mergeSort(vector<int>& nums, int left, int right) {
    if (left >= right) return;  // 只有一个元素时返回
    int mid = left + (right - left) / 2;
    mergeSort(nums, left, mid);       // 左半边排好
    mergeSort(nums, mid + 1, right);   // 右半边排好
    merge(nums, left, mid, right);     // 合并
}
```
（调用时：`mergeSort(nums, 0, nums.size() - 1);`）

#### 讲解
- `mergeSort`：不断地二分，把数组分成小块。
- `merge`：把左右两部分合并成一个有序数组。
- 使用**额外数组**辅助合并。

---
### Q4： 堆排序:
#### 核心思想
> 把数组看成**堆（大根堆/小根堆）**，不断把堆顶元素（最大或最小）取出放到数组尾部。

- 构建堆 → 取堆顶 → 调整堆 → 继续取堆顶。

#### 操作流程
1. 把整个数组**建成一个大根堆**（堆顶是最大元素）。
2. 取出堆顶元素，放到数组末尾。
3. 调整剩余部分为新的大根堆。
4. 重复，直到排序完成。

#### 示例
排序 `[4, 2, 5, 1, 3]`：

- 建大根堆：堆化成 `[5, 3, 4, 1, 2]`
- 取5放到最后 ➔ `[2, 3, 4, 1, 5]`
- 再堆化 ➔ `[4, 3, 2, 1, 5]`
- 取4放到次尾 ➔ `[1, 3, 2, 4, 5]`
- 再堆化 ➔ `[3, 1, 2, 4, 5]`
- 以此类推，最终 `[1, 2, 3, 4, 5]`

#### 时间复杂度
- 建堆：O(n)
- 取元素：O(log n) × n次
- 总体：**O(n log n)**
- 空间复杂度：**O(1)**（原地完成，不需要额外数组）

**具体实现：**
```cpp
void heapify(vector<int>& nums, int n, int i) {
    int largest = i;       // 当前节点
    int l = 2 * i + 1;     // 左子节点
    int r = 2 * i + 2;     // 右子节点

    if (l < n && nums[l] > nums[largest]) largest = l;
    if (r < n && nums[r] > nums[largest]) largest = r;

    if (largest != i) {
        swap(nums[i], nums[largest]);  // 交换
        heapify(nums, n, largest);     // 递归调整下面的子堆
    }
}

void heapSort(vector<int>& nums) {
    int n = nums.size();
    
    // 建堆（从最后一个非叶子节点开始）
    for (int i = n / 2 - 1; i >= 0; --i) {
        heapify(nums, n, i);
    }
    
    // 一个个取出堆顶元素（最大值）
    for (int i = n - 1; i > 0; --i) {
        swap(nums[0], nums[i]);   // 交换堆顶到末尾
        heapify(nums, i, 0);      // 重新调整剩余堆
    }
}
```
### 🚀 讲解
- `heapify`：让节点`i`以下保持堆结构（父节点最大）。
- 先把整个数组调整成大根堆。
- 然后不断取出堆顶元素，放到最后，缩小堆大小，继续调整。

---
### Q5：冒泡排序
#### 思想
- 每一轮，把最大的元素“冒泡”到数组末尾。
- 相邻元素两两比较，发现顺序错了就交换。

#### 过程
举例：[5, 2, 4, 3, 1]

第一轮：  
- 5和2比，5>2，交换 → [2,5,4,3,1]  
- 5和4比，5>4，交换 → [2,4,5,3,1]  
- 5和3比，5>3，交换 → [2,4,3,5,1]  
- 5和1比，5>1，交换 → [2,4,3,1,5]（5到了最后）

继续第二轮、第三轮，直到全部有序。

#### 代码（C++版）
```cpp
void bubbleSort(vector<int>& nums) {
    int n = nums.size();
    for (int i = 0; i < n-1; ++i) { 
        for (int j = 0; j < n-i-1; ++j) { // 注意是 n-i-1
            if (nums[j] > nums[j+1]) {
                swap(nums[j], nums[j+1]);
            }
        }
    }
}
```

#### 时间复杂度
- 最好：O(n)（如果加了“有序检测”优化）
- 最坏：O(n²)
- 空间复杂度：O(1)（原地排序）

#### 特点
- 思想简单
- 小数组可以用，但大数组性能很差！

---
### Q6：快速排序
#### 思想
- 分治法。
- 随机选一个“基准”（pivot），把数组分成**小于pivot**和**大于pivot**两部分，分别递归排序。

#### 过程
举例：[5, 2, 4, 3, 1]

- 选 5 做基准。
- 小于5的：[2,4,3,1]，大于5的：[]。
- 对[2,4,3,1]继续快排...
- 最后组合成：[1,2,3,4,5]

#### 代码
```cpp
int partition(vector<int>& nums, int left, int right) {
    int pivot = nums[right]; // 选最后一个作为基准
    int i = left - 1;
    for (int j = left; j < right; ++j) {
        if (nums[j] <= pivot) {
            ++i;
            swap(nums[i], nums[j]);
        }
    }
    swap(nums[i+1], nums[right]);
    return i+1;
}

void quickSort(vector<int>& nums, int left, int right) {
    if (left >= right) return;
    int pivotIndex = partition(nums, left, right);
    quickSort(nums, left, pivotIndex-1);
    quickSort(nums, pivotIndex+1, right);
}
```

调用：
```cpp
vector<int> nums = {5,2,4,3,1};
quickSort(nums, 0, nums.size()-1);
```

#### 时间复杂度
- 最好：O(n log n)
- 平均：O(n log n)
- 最坏：O(n²)（如果每次 pivot 很烂，比如总是最小值）
- 空间复杂度：O(log n)（递归栈空间）

#### 特点
- 排序速度非常快，是实际工程应用中最常用的排序之一！
- 随机选 pivot（Randomized QuickSort）可以避免最坏情况。

---
## C/C++ 基础

### Q1: 如何定义和实现一个类的成员函数为回调函数？？

**答：**

**回调函数**的问题在于，外部系统只接受普通函数指针，但我们的成员函数需要对象实例才能调用，这两者是不匹配的。
解决这个问题有两种主要方法：
1. 第一种是用**静态成员函数**做桥梁。因为静态函数不需要对象实例，可以当作普通函数指针使用。具体做法是定义一个静态函数，通过void指针参数把对象地址传进去，然后在静态函数里面**转换指针类型**，调用真正的成员函数。这种方法适合与C库或底层API交互。
2. 第二种是用**Lambda表达式**配合std::function。Lambda可以捕获外部的对象，当外部系统调用Lambda时，Lambda再去调用我们的成员函数。比如写成lambda括号里面放&obj来捕获对象，然后在Lambda体里调用obj.memberFunction()。这种方法更现代，适合纯C++项目。

两种方法的核心思想都是一样的：让外部系统能够间接调用你的成员函数，只是实现方式不同。选择哪种主要看你的使用场景和项目要求。

---
### Q2: strcpy函数安全吗？如果不安全，用什么去替代？
**答：**

---

## Linux / 系统编程

### Q1: 什么？

**答：**

- 进程是资源分配的基本单位，线程是 CPU 调度的基本单位。
- 一个进程可以包含多个线程。
- 线程共享进程的资源，进程间资源独立。
- 创建/切换线程的开销比进程小。

**举例子：**

- xxxxx。


---

## 数据库

### Q1: 什么？

**答：**

- 进程是资源分配的基本单位，线程是 CPU 调度的基本单位。
- 一个进程可以包含多个线程。
- 线程共享进程的资源，进程间资源独立。
- 创建/切换线程的开销比进程小。

**举例子：**

- xxxxx。


---

## 设计模式

### Q1: 什么？

**答：**

- 进程是资源分配的基本单位，线程是 CPU 调度的基本单位。
- 一个进程可以包含多个线程。
- 线程共享进程的资源，进程间资源独立。
- 创建/切换线程的开销比进程小。

**举例子：**

- xxxxx。


---

## 音视频相关

### Q1: 什么？

**答：**

- 进程是资源分配的基本单位，线程是 CPU 调度的基本单位。
- 一个进程可以包含多个线程。
- 线程共享进程的资源，进程间资源独立。
- 创建/切换线程的开销比进程小。

**举例子：**

- xxxxx。


---


## 其他

### Q1: 什么？

**答：**

- 进程是资源分配的基本单位，线程是 CPU 调度的基本单位。
- 一个进程可以包含多个线程。
- 线程共享进程的资源，进程间资源独立。
- 创建/切换线程的开销比进程小。

**举例子：**

- xxxxx。


---
