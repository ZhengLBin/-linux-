# 📘 计算机八股文题库

> 📅 更新日期：2025-06-18  
> 🧩 内容结构：按知识点分类 + 问题列表 + 答案详解  

---

## ✳️ 目录

- [操作系统](#操作系统)
- [计算机网络](#计算机网络)
- [数据结构与算法](#数据结构与算法)
- [C/C++ 基础](#cc-基础)
- [Linux / 系统编程](#linux--系统编程)
- [数据库](#数据库)
- [设计模式](#设计模式)
- [音视频相关](#音视频相关)
- [其他](#其他)


---

## 操作系统

### Q1: 什么？

**答：**

- 进程是资源分配的基本单位，线程是 CPU 调度的基本单位。
- 一个进程可以包含多个线程。
- 线程共享进程的资源，进程间资源独立。
- 创建/切换线程的开销比进程小。

**举例子：**

- xxxxx。


---

## 计算机网络

### Q1: 什么？

**答：**

- 进程是资源分配的基本单位，线程是 CPU 调度的基本单位。
- 一个进程可以包含多个线程。
- 线程共享进程的资源，进程间资源独立。
- 创建/切换线程的开销比进程小。

**举例子：**

- xxxxx。


---

## 数据结构与算法

### Q1: 选择排序

#### 核心思想
> 每一轮都找**当前未排序部分中最小的元素**，把它放到**最前面**。

- 选择 → 交换。

#### 操作流程（以升序为例）
1. 从头开始，找到整个数组中最小的元素。
2. 把最小元素和第一个元素交换。
3. 再从第二个元素开始，找剩余中最小的，交换到第二个位置。
4. 以此类推，直到整个数组有序。


####  示例
排序 `[4, 2, 5, 1, 3]`：

- 找最小1，交换到第0位 ➔ `[1, 2, 5, 4, 3]`
- 找剩下最小2，已经在第1位，不动 ➔ `[1, 2, 5, 4, 3]`
- 找剩下最小3，交换到第2位 ➔ `[1, 2, 3, 4, 5]`
- 剩下自然有序。


#### 时间复杂度
- 最好、最坏、平均：**O(n²)**
- 空间复杂度：**O(1)**（原地排序）

**具体实现：**

```cpp
void selectionSort(vector<int>& nums) {
    int n = nums.size();
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;  // 假设当前位置i是最小的
        for (int j = i + 1; j < n; ++j) {
            if (nums[j] < nums[minIndex]) {
                minIndex = j;  // 找到更小的元素
            }
        }
        swap(nums[i], nums[minIndex]);  // 把最小的元素放到当前i的位置
    }
}
```
#### 讲解
- 外层循环：每次确定一个元素的位置。
- 内层循环：找从 `i` 到 `n-1` 最小的元素。
- 交换：把最小元素放到前面。

---
### Q2: 插入排序

#### 核心思想
> 每次拿一个新元素，**插入到已排好序的左边部分**，保持左边始终有序。

- 插入 → 移动 → 插入合适位置。


#### 操作流程
1. 第一个元素默认有序。
2. 第二个元素向左比较，插入合适位置。
3. 第三个元素向左比较，插入。
4. 以此类推。



#### 示例
排序 `[4, 2, 5, 1, 3]`：

- 4，自己有序。
- 2，比4小，插到前面 ➔ `[2, 4, 5, 1, 3]`
- 5，比4大，直接放后面。
- 1，比2小，插到最前 ➔ `[1, 2, 4, 5, 3]`
- 3，比5小，比4小，比2大，插到2后 ➔ `[1, 2, 3, 4, 5]`


#### 时间复杂度
- 最好（已经有序）：**O(n)**
- 最坏、平均：**O(n²)**
- 空间复杂度：**O(1)**

**具体实现：**

```cpp
void insertionSort(vector<int>& nums) {
    int n = nums.size();
    for (int i = 1; i < n; ++i) {
        int key = nums[i];  // 当前要插入的元素
        int j = i - 1;
        // 从后往前找位置
        while (j >= 0 && nums[j] > key) {
            nums[j + 1] = nums[j];  // 把大元素往后挪
            --j;
        }
        nums[j + 1] = key;  // 插入到正确位置
    }
}
```

#### 讲解
- `key`是当前新来的元素。
- 内层循环：把左边大于`key`的元素往后移动。
- 插入：空出的位置就是`key`该插的位置。

---
### Q3: 归并排序
#### 核心思想
> 把数组一分为二，分别排好序，然后**合并成一个有序数组**。

- 分治思想：**分而治之**！

#### 操作流程
1. 把数组对半分成两部分。
2. 递归地分别对左右部分排序。
3. 合并两个排好序的子数组。

#### 示例
排序 `[4, 2, 5, 1, 3]`：

- 切分： `[4,2,5]` `[1,3]`
- `[4,2,5]`继续分成 `[4] [2,5]`
- `[2,5]`分成 `[2] [5]`
- 合并`[2,5]`
- 合并`[4,2,5]` ➔ `[2,4,5]`
- `[1,3]`分成 `[1] [3]` ➔ 合并 `[1,3]`
- 最后合并 `[2,4,5]` 和 `[1,3]` ➔ `[1,2,3,4,5]`

#### 时间复杂度
- 不管怎样都是：**O(n log n)**
- 空间复杂度：**O(n)**（需要额外辅助数组）

**具体实现：**
```cpp
void merge(vector<int>& nums, int left, int mid, int right) {
    vector<int> temp; // 临时数组
    int i = left, j = mid + 1;
    while (i <= mid && j <= right) {
        if (nums[i] <= nums[j]) {
            temp.push_back(nums[i++]);
        } else {
            temp.push_back(nums[j++]);
        }
    }
    while (i <= mid) temp.push_back(nums[i++]);
    while (j <= right) temp.push_back(nums[j++]);
    
    // 把排好序的temp拷回原数组
    for (int k = 0; k < temp.size(); ++k) {
        nums[left + k] = temp[k];
    }
}

void mergeSort(vector<int>& nums, int left, int right) {
    if (left >= right) return;  // 只有一个元素时返回
    int mid = left + (right - left) / 2;
    mergeSort(nums, left, mid);       // 左半边排好
    mergeSort(nums, mid + 1, right);   // 右半边排好
    merge(nums, left, mid, right);     // 合并
}
```
（调用时：`mergeSort(nums, 0, nums.size() - 1);`）

#### 讲解
- `mergeSort`：不断地二分，把数组分成小块。
- `merge`：把左右两部分合并成一个有序数组。
- 使用**额外数组**辅助合并。

---
### Q4： 堆排序:
#### 核心思想
> 把数组看成**堆（大根堆/小根堆）**，不断把堆顶元素（最大或最小）取出放到数组尾部。

- 构建堆 → 取堆顶 → 调整堆 → 继续取堆顶。

#### 操作流程
1. 把整个数组**建成一个大根堆**（堆顶是最大元素）。
2. 取出堆顶元素，放到数组末尾。
3. 调整剩余部分为新的大根堆。
4. 重复，直到排序完成。

#### 示例
排序 `[4, 2, 5, 1, 3]`：

- 建大根堆：堆化成 `[5, 3, 4, 1, 2]`
- 取5放到最后 ➔ `[2, 3, 4, 1, 5]`
- 再堆化 ➔ `[4, 3, 2, 1, 5]`
- 取4放到次尾 ➔ `[1, 3, 2, 4, 5]`
- 再堆化 ➔ `[3, 1, 2, 4, 5]`
- 以此类推，最终 `[1, 2, 3, 4, 5]`

#### 时间复杂度
- 建堆：O(n)
- 取元素：O(log n) × n次
- 总体：**O(n log n)**
- 空间复杂度：**O(1)**（原地完成，不需要额外数组）

**具体实现：**
```cpp
void heapify(vector<int>& nums, int n, int i) {
    int largest = i;       // 当前节点
    int l = 2 * i + 1;     // 左子节点
    int r = 2 * i + 2;     // 右子节点

    if (l < n && nums[l] > nums[largest]) largest = l;
    if (r < n && nums[r] > nums[largest]) largest = r;

    if (largest != i) {
        swap(nums[i], nums[largest]);  // 交换
        heapify(nums, n, largest);     // 递归调整下面的子堆
    }
}

void heapSort(vector<int>& nums) {
    int n = nums.size();
    
    // 建堆（从最后一个非叶子节点开始）
    for (int i = n / 2 - 1; i >= 0; --i) {
        heapify(nums, n, i);
    }
    
    // 一个个取出堆顶元素（最大值）
    for (int i = n - 1; i > 0; --i) {
        swap(nums[0], nums[i]);   // 交换堆顶到末尾
        heapify(nums, i, 0);      // 重新调整剩余堆
    }
}
```
### 🚀 讲解
- `heapify`：让节点`i`以下保持堆结构（父节点最大）。
- 先把整个数组调整成大根堆。
- 然后不断取出堆顶元素，放到最后，缩小堆大小，继续调整。

---
### Q5：冒泡排序
#### 思想
- 每一轮，把最大的元素“冒泡”到数组末尾。
- 相邻元素两两比较，发现顺序错了就交换。

#### 过程
举例：[5, 2, 4, 3, 1]

第一轮：  
- 5和2比，5>2，交换 → [2,5,4,3,1]  
- 5和4比，5>4，交换 → [2,4,5,3,1]  
- 5和3比，5>3，交换 → [2,4,3,5,1]  
- 5和1比，5>1，交换 → [2,4,3,1,5]（5到了最后）

继续第二轮、第三轮，直到全部有序。

#### 代码（C++版）
```cpp
void bubbleSort(vector<int>& nums) {
    int n = nums.size();
    for (int i = 0; i < n-1; ++i) { 
        for (int j = 0; j < n-i-1; ++j) { // 注意是 n-i-1
            if (nums[j] > nums[j+1]) {
                swap(nums[j], nums[j+1]);
            }
        }
    }
}
```

#### 时间复杂度
- 最好：O(n)（如果加了“有序检测”优化）
- 最坏：O(n²)
- 空间复杂度：O(1)（原地排序）

#### 特点
- 思想简单
- 小数组可以用，但大数组性能很差！

---
### Q6：快速排序
#### 思想
- 分治法。
- 随机选一个“基准”（pivot），把数组分成**小于pivot**和**大于pivot**两部分，分别递归排序。

#### 过程
举例：[5, 2, 4, 3, 1]

- 选 5 做基准。
- 小于5的：[2,4,3,1]，大于5的：[]。
- 对[2,4,3,1]继续快排...
- 最后组合成：[1,2,3,4,5]

#### 代码
```cpp
int partition(vector<int>& nums, int left, int right) {
    int pivot = nums[right]; // 选最后一个作为基准
    int i = left - 1;
    for (int j = left; j < right; ++j) {
        if (nums[j] <= pivot) {
            ++i;
            swap(nums[i], nums[j]);
        }
    }
    swap(nums[i+1], nums[right]);
    return i+1;
}

void quickSort(vector<int>& nums, int left, int right) {
    if (left >= right) return;
    int pivotIndex = partition(nums, left, right);
    quickSort(nums, left, pivotIndex-1);
    quickSort(nums, pivotIndex+1, right);
}
```

调用：
```cpp
vector<int> nums = {5,2,4,3,1};
quickSort(nums, 0, nums.size()-1);
```

#### 时间复杂度
- 最好：O(n log n)
- 平均：O(n log n)
- 最坏：O(n²)（如果每次 pivot 很烂，比如总是最小值）
- 空间复杂度：O(log n)（递归栈空间）

#### 特点
- 排序速度非常快，是实际工程应用中最常用的排序之一！
- 随机选 pivot（Randomized QuickSort）可以避免最坏情况。

---
## C/C++ 基础

### Q1: 如何定义和实现一个类的成员函数为回调函数？？

**答：**
**回调函数**必须是无状态的（或通过参数传递状态），而成员函数需要 this，因此需间接调用。
**回调函数（Callback Function）** 是一种 **"你定义，别人调用"** 的机制：
- **你** 先写一个函数（回调函数）并 **注册** 到某个系统或框架（如 Windows API、定时器、事件处理器等）。
- **系统** 在特定事件（如鼠标点击、数据到达、定时触发）发生时 **自动调用** 你的函数。

**举例子：**
- 你点外卖（**注册回调**）：
  - 你告诉外卖平台："餐到了请打电话给我"（**回调函数**）。
  - 外卖员送到后（**事件发生**），平台 **自动打电话通知你**（**调用回调**）。

#### **实现方法详解**

##### **方法 1：静态成员函数 + 对象指针（最通用）**
##### **适用场景**
- C 风格回调（如 Win32 API、POSIX 信号、第三方库）。

##### **实现步骤**
1. 定义一个 **静态成员函数**（无 `this`，符合回调要求）。
2. 通过参数（如 `void*`）传递对象指针。
3. 在静态函数中 **转换指针并调用真正的成员函数**。

##### **代码示例**
```cpp
class MyApp {
public:
    void onData(int data) {  // 真正的回调逻辑
        std::cout << "Data received: " << data << std::endl;
    }

    // 静态函数（符合C回调签名）
    static void Callback(int data, void* obj) {
        static_cast<MyApp*>(obj)->onData(data);  // 调用成员函数
    }
};

// 注册回调（假设是某个C库的函数）
void register_callback(void (*cb)(int, void*), void* userdata) {
    cb(42, userdata);  // 模拟事件触发
}

int main() {
    MyApp app;
    register_callback(&MyApp::Callback, &app);  // 注册时传递对象指针
    return 0;
}
```
**输出**：
```
Data received: 42
```

---

##### **方法 2：Lambda + std::function（现代 C++ 推荐）**
##### **适用场景**
- C++ 接口（如异步任务、事件驱动框架）。

##### **实现步骤**
1. 用 **Lambda 捕获对象**（`[&obj]`）。
2. 将 Lambda 传递给支持 `std::function` 的回调接口。

##### **代码示例**
```cpp
#include <functional>
#include <iostream>

class MyApp {
public:
    void onEvent(int value) {
        std::cout << "Event: " << value << std::endl;
    }
};

// 支持 std::function 的注册函数
void register_event(const std::function<void(int)>& cb) {
    cb(42);  // 触发事件
}

int main() {
    MyApp app;
    // 用 Lambda 捕获 app 并调用 onEvent
    register_event([&app](int val) { app.onEvent(val); });
    return 0;
}
```
**输出**：
```
Event: 42
```

---

## Linux / 系统编程

### Q1: 什么？

**答：**

- 进程是资源分配的基本单位，线程是 CPU 调度的基本单位。
- 一个进程可以包含多个线程。
- 线程共享进程的资源，进程间资源独立。
- 创建/切换线程的开销比进程小。

**举例子：**

- xxxxx。


---

## 数据库

### Q1: 什么？

**答：**

- 进程是资源分配的基本单位，线程是 CPU 调度的基本单位。
- 一个进程可以包含多个线程。
- 线程共享进程的资源，进程间资源独立。
- 创建/切换线程的开销比进程小。

**举例子：**

- xxxxx。


---

## 设计模式

### Q1: 什么？

**答：**

- 进程是资源分配的基本单位，线程是 CPU 调度的基本单位。
- 一个进程可以包含多个线程。
- 线程共享进程的资源，进程间资源独立。
- 创建/切换线程的开销比进程小。

**举例子：**

- xxxxx。


---

## 音视频相关

### Q1: 什么？

**答：**

- 进程是资源分配的基本单位，线程是 CPU 调度的基本单位。
- 一个进程可以包含多个线程。
- 线程共享进程的资源，进程间资源独立。
- 创建/切换线程的开销比进程小。

**举例子：**

- xxxxx。


---


## 其他

### Q1: 什么？

**答：**

- 进程是资源分配的基本单位，线程是 CPU 调度的基本单位。
- 一个进程可以包含多个线程。
- 线程共享进程的资源，进程间资源独立。
- 创建/切换线程的开销比进程小。

**举例子：**

- xxxxx。


---
